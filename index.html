<!DOCTYPE html>
<html>
<head>
  <title>Professional Cipher Breaker</title>
  <style>
    body {
      font-family: 'Consolas', monospace;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f8f9fa;
      color: #333;
    }
    .container {
      background: white;
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
    }
    textarea {
      width: 100%;
      height: 200px;
      padding: 15px;
      font-size: 16px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      resize: vertical;
      font-family: 'Consolas', monospace;
    }
    button {
      background: #2c3e50;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 18px;
      cursor: pointer;
      border-radius: 6px;
      margin: 20px 0;
      transition: all 0.3s;
      font-weight: bold;
    }
    button:hover {
      background: #1a252f;
      transform: translateY(-2px);
    }
    .progress-container {
      height: 10px;
      background: #ecf0f1;
      margin: 25px 0;
      border-radius: 5px;
      overflow: hidden;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      width: 0%;
      transition: width 0.5s;
    }
    .results {
      margin-top: 30px;
    }
    .result-card {
      background: white;
      border-left: 5px solid #3498db;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
      transition: all 0.3s;
    }
    .result-card:hover {
      transform: translateX(5px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    .cipher-name {
      color: #2c3e50;
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .key {
      font-family: 'Courier New', monospace;
      background: #f1f1f1;
      padding: 3px 6px;
      border-radius: 3px;
      color: #e74c3c;
    }
    .confidence {
      color: #27ae60;
      font-weight: bold;
    }
    .decrypted-text {
      margin-top: 15px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 4px;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
    }
    .tab {
      display: inline-block;
      margin-left: 40px;
    }
    .advanced-options {
      margin: 20px 0;
      padding: 15px;
      background: #f1f8fe;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Professional Cipher Breaker</h1>
    <p>Advanced cryptographic analysis tool with 20+ cipher support</p>
    
    <textarea id="input" placeholder="Enter encrypted text here..."></textarea>
    
    <div class="advanced-options">
      <h3>Analysis Options</h3>
      <div>
        <input type="checkbox" id="deep-analysis" checked>
        <label for="deep-analysis">Deep analysis (slower but more thorough)</label>
      </div>
      <div>
        <input type="checkbox" id="bruteforce" checked>
        <label for="bruteforce">Enable brute-force attacks</label>
      </div>
    </div>
    
    <button onclick="startAnalysis()">ANALYZE CIPHERS</button>
    
    <div class="progress-container">
      <div class="progress-bar" id="progress-bar"></div>
    </div>
    
    <div id="status">Ready to analyze</div>
    
    <div class="results" id="results"></div>
  </div>

<script>
// ======================== Cipher Database ========================
const CipherDatabase = {
  // Classical Ciphers
  CAESAR: {
    name: "Caesar Cipher",
    type: "substitution",
    description: "Simple shift cipher where each letter is shifted by a fixed number",
    decrypt: function(text, shift) {
      return text.replace(/[a-z]/gi, c => {
        const base = c <= 'Z' ? 65 : 97;
        return String.fromCharCode((c.charCodeAt(0) - base - shift + 26) % 26 + base);
      });
    },
    analyze: function(text) {
      const results = [];
      for (let shift = 0; shift < 26; shift++) {
        const decrypted = this.decrypt(text, shift);
        const score = AnalyzerEngine.rateEnglishText(decrypted);
        if (score > 50) {
          results.push({
            cipher: this.name,
            method: `Shift ${shift}`,
            decrypted: decrypted,
            confidence: score,
            details: {
              shift: shift
            }
          });
        }
      }
      return results;
    }
  },

  VIGENERE: {
    name: "Vigenère Cipher",
    type: "polyalphabetic",
    description: "Uses a keyword to shift letters with varying amounts",
    decrypt: function(text, key) {
      let result = "";
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (/[a-z]/i.test(c)) {
          const base = c <= 'Z' ? 65 : 97;
          const keyChar = key[i % key.length].toUpperCase();
          const shift = keyChar.charCodeAt(0) - 65;
          result += String.fromCharCode((c.charCodeAt(0) - base - shift + 26) % 26 + base);
        } else {
          result += c;
        }
      }
      return result;
    },
    analyze: function(text) {
      const results = [];
      const keyLength = AnalyzerEngine.findKeyLength(text);
      
      // Test common keys first
      const commonKeys = ["KEY", "SECRET", "CODE", "CRYPTO", "PASSWORD"];
      for (const key of commonKeys) {
        const decrypted = this.decrypt(text, key);
        const score = AnalyzerEngine.rateEnglishText(decrypted);
        if (score > 60) {
          results.push({
            cipher: this.name,
            method: `Key: ${key}`,
            decrypted: decrypted,
            confidence: score,
            details: {
              key: key,
              keyLength: key.length
            }
          });
        }
      }
      
      // Brute-force short keys
      if (document.getElementById('bruteforce').checked) {
        const maxKeyLength = Math.min(keyLength + 2, 5);
        for (let len = 1; len <= maxKeyLength; len++) {
          const keyGenerator = AnalyzerEngine.generateKeys(len);
          let attempts = 0;
          const maxAttempts = Math.pow(26, len) / 10; // Sample 10% of keyspace
          
          while (attempts++ < maxAttempts) {
            const key = keyGenerator.next().value;
            const decrypted = this.decrypt(text, key);
            const score = AnalyzerEngine.rateEnglishText(decrypted);
            if (score > 70) {
              results.push({
                cipher: this.name,
                method: `Key: ${key}`,
                decrypted: decrypted,
                confidence: score,
                details: {
                  key: key,
                  keyLength: key.length
                }
              });
            }
          }
        }
      }
      
      return results;
    }
  },

  // Add 18 more ciphers here with the same structure...
  // Each cipher should have:
  // - name
  // - type
  // - description
  // - decrypt function
  // - analyze function
  
  // Example of another cipher:
  XOR: {
    name: "XOR Cipher",
    type: "modern",
    description: "Bitwise XOR operation with a key",
    decrypt: function(text, key) {
      let result = "";
      for (let i = 0; i < text.length; i++) {
        result += String.fromCharCode(text.charCodeAt(i) ^ key);
      }
      return result;
    },
    analyze: function(text) {
      const results = [];
      // Test common XOR keys
      const commonKeys = [0x55, 0xAA, 0xFF, 0x20, 0x7F];
      
      for (const key of commonKeys) {
        const decrypted = this.decrypt(text, key);
        const score = AnalyzerEngine.rateEnglishText(decrypted);
        if (score > 60) {
          results.push({
            cipher: this.name,
            method: `Key: 0x${key.toString(16).toUpperCase()}`,
            decrypted: decrypted,
            confidence: score,
            details: {
              key: key,
              keyHex: `0x${key.toString(16).toUpperCase()}`
            }
          });
        }
      }
      
      // Brute-force if enabled
      if (document.getElementById('bruteforce').checked) {
        for (let key = 1; key < 256; key++) {
          const decrypted = this.decrypt(text, key);
          const score = AnalyzerEngine.rateEnglishText(decrypted);
          if (score > 70) {
            results.push({
              cipher: this.name,
              method: `Key: 0x${key.toString(16).toUpperCase()}`,
              decrypted: decrypted,
              confidence: score,
              details: {
                key: key,
                keyHex: `0x${key.toString(16).toUpperCase()}`
              }
            });
          }
        }
      }
      
      return results;
    }
  }
};

// ======================== Analyzer Engine ========================
const AnalyzerEngine = {
  // English language frequency analysis
  englishFrequencies: {
    mono: {
      'E': 12.70, 'T': 9.10, 'A': 8.20, 'O': 7.50, 'I': 7.00,
      'N': 6.70, 'S': 6.30, 'H': 6.10, 'R': 6.00, 'D': 4.30,
      'L': 4.00, 'C': 2.80, 'U': 2.80, 'M': 2.40, 'W': 2.40,
      'F': 2.20, 'G': 2.00, 'Y': 2.00, 'P': 1.90, 'B': 1.50,
      'V': 1.00, 'K': 0.80, 'J': 0.20, 'X': 0.20, 'Q': 0.10,
      'Z': 0.10
    },
    bi: {
      'TH': 3.56, 'HE': 3.07, 'IN': 2.43, 'ER': 2.05, 'AN': 1.99,
      'RE': 1.85, 'ND': 1.78, 'AT': 1.76, 'ON': 1.61, 'NT': 1.61
    },
    tri: {
      'THE': 3.56, 'AND': 1.73, 'ING': 1.15, 'ION': 1.00, 'ENT': 0.98,
      'HER': 0.89, 'FOR': 0.88, 'THA': 0.88, 'NTH': 0.87, 'INT': 0.80
    }
  },

  commonWords: [
    'THE', 'BE', 'TO', 'OF', 'AND', 'A', 'IN', 'THAT', 'HAVE', 'I',
    'IT', 'FOR', 'NOT', 'ON', 'WITH', 'HE', 'AS', 'YOU', 'DO', 'AT'
  ],

  // Rate how English-like the text is (0-100)
  rateEnglishText: function(text) {
    if (!text || text.length < 3) return 0;
    
    const cleanText = text.toUpperCase().replace(/[^A-Z]/g, '');
    if (cleanText.length < 3) return 0;
    
    let score = 0;
    
    // 1. Check for common words
    for (const word of this.commonWords) {
      if (cleanText.includes(word)) {
        score += word.length * 5;
      }
    }
    
    // 2. Monogram frequency
    const monoCounts = {};
    let monoTotal = 0;
    for (const char of cleanText) {
      monoCounts[char] = (monoCounts[char] || 0) + 1;
      monoTotal++;
    }
    
    for (const char in monoCounts) {
      const observed = (monoCounts[char] / monoTotal) * 100;
      const expected = this.englishFrequencies.mono[char] || 0;
      score += 10 - Math.abs(observed - expected) / 10;
    }
    
    // 3. Bigram frequency
    for (let i = 0; i < cleanText.length - 1; i++) {
      const bigram = cleanText.substr(i, 2);
      const expected = this.englishFrequencies.bi[bigram] || 0;
      score += expected / 2;
    }
    
    // Normalize score
    const maxPossible = 100 + (this.commonWords.length * 10);
    return Math.min(100, Math.max(0, (score / maxPossible) * 100));
  },

  // Find likely key length for Vigenère
  findKeyLength: function(text, maxLength = 15) {
    const cleanText = text.toUpperCase().replace(/[^A-Z]/g, '');
    if (cleanText.length < 20) return 3;
    
    // Kasiski examination
    const distances = [];
    const trigrams = {};
    
    // Find repeating trigrams and their distances
    for (let i = 0; i < cleanText.length - 3; i++) {
      const trigram = cleanText.substr(i, 3);
      if (trigrams[trigram]) {
        trigrams[trigram].push(i);
      } else {
        trigrams[trigram] = [i];
      }
    }
    
    // Calculate distances between repeats
    for (const trigram in trigrams) {
      if (trigrams[trigram].length > 1) {
        for (let i = 1; i < trigrams[trigram].length; i++) {
          distances.push(trigrams[trigram][i] - trigrams[trigram][0]);
        }
      }
    }
    
    // Find GCD of distances
    if (distances.length === 0) return 3;
    
    const gcd = (a, b) => b ? gcd(b, a % b) : a;
    let currentGCD = distances[0];
    for (let i = 1; i < distances.length; i++) {
      currentGCD = gcd(currentGCD, distances[i]);
      if (currentGCD === 1) break;
    }
    
    return Math.min(maxLength, Math.max(1, currentGCD));
  },

  // Generate all possible keys of given length
  *generateKeys(length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (let i = 0; i < Math.pow(26, length); i++) {
      let key = '';
      let n = i;
      for (let j = 0; j < length; j++) {
        key += chars[n % 26];
        n = Math.floor(n / 26);
      }
      yield key;
    }
  }
};

// ======================== UI Controller ========================
function startAnalysis() {
  const input = document.getElementById('input').value.trim();
  if (!input) {
    updateStatus("Please enter text to analyze", "error");
    return;
  }
  
  const resultsContainer = document.getElementById('results');
  resultsContainer.innerHTML = '';
  updateStatus("Starting analysis...");
  
  // Get all ciphers to analyze
  const ciphersToAnalyze = Object.values(CipherDatabase);
  const totalSteps = ciphersToAnalyze.length;
  let completed = 0;
  
  // Process each cipher
  ciphersToAnalyze.forEach(cipher => {
    setTimeout(() => {
      try {
        updateStatus(`Analyzing ${cipher.name}...`);
        updateProgress((completed / totalSteps) * 100);
        
        const results = cipher.analyze(input);
        displayResults(results);
        
        completed++;
        updateProgress((completed / totalSteps) * 100);
        
        if (completed === totalSteps) {
          updateStatus("Analysis complete");
        }
      } catch (e) {
        console.error(`Error analyzing ${cipher.name}:`, e);
        completed++;
      }
    }, 0);
  });
}

function displayResults(results) {
  if (!results || results.length === 0) return;
  
  const container = document.getElementById('results');
  
  results.forEach(result => {
    const card = document.createElement('div');
    card.className = 'result-card';
    
    card.innerHTML = `
      <div class="cipher-name">${result.cipher} - ${result.method}</div>
      <div>Confidence: <span class="confidence">${Math.round(result.confidence)}%</span></div>
      ${result.details ? `<div>Details: ${JSON.stringify(result.details)}</div>` : ''}
      <div class="decrypted-text">${result.decrypted.length > 200 ? 
        result.decrypted.substring(0, 200) + '...' : result.decrypted}</div>
    `;
    
    container.appendChild(card);
  });
}

function updateStatus(message, type = "info") {
  const statusElement = document.getElementById('status');
  statusElement.textContent = message;
  statusElement.style.color = type === "error" ? "#e74c3c" : "#2c3e50";
}

function updateProgress(percent) {
  document.getElementById('progress-bar').style.width = `${percent}%`;
}
</script>
</body>
</html>
