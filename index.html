<!DOCTYPE html>
<html>
<head>
    <title>CryptoPro Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: monospace; background: #0a0a0a; color: #00ff00; padding: 20px; }
        .container { max-width: 1200px; margin: auto; }
        textarea, button, pre { 
            background: #000; color: #0f0; border: 1px solid #0f0; 
            width: 100%; margin: 10px 0; padding: 10px;
        }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        canvas { background: #000; }
        .hypothesis { border: 1px solid #0f0; padding: 15px; margin: 10px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ†Ô∏è CryptoPro Analyzer</h1>
        <textarea id="ciphertext" rows="5" placeholder="Ciphertext..."></textarea>
        <button onclick="startAnalysis()">Analyze</button>
        <div class="grid">
            <div id="results"></div>
            <canvas id="chart"></canvas>
        </div>
    </div>

<script>
const CryptoPro = {
    // 1. –ú–µ—Ç–æ–¥ –ö–∞—Å–∏—Å–∫–∏ –¥–ª—è –í–∏–∂–µ–Ω–µ—Ä–∞
    kasiski: (text, gramSize = 3) => {
        const grams = {};
        for (let i = 0; i < text.length - gramSize + 1; i++) {
            const gram = text.slice(i, i + gramSize);
            grams[gram] = grams[gram] ? [...grams[gram], i] : [i];
        }
        
        const distances = [];
        for (const gram in grams) {
            if (grams[gram].length > 1) {
                for (let i = 1; i < grams[gram].length; i++) {
                    distances.push(grams[gram][i] - grams[gram][i-1]);
                }
            }
        }
        
        const factors = {};
        distances.forEach(d => {
            for (let i = 2; i <= 20; i++) {
                if (d % i === 0) factors[i] = (factors[i] || 0) + 1;
            }
        });
        
        return Object.entries(factors).sort((a, b) => b[1] - a[1])[0]?.[0] || null;
    },

    // 2. –¢—Ä–∞–Ω—Å–ø–æ–∑–∏—Ü–∏—è —Å –∞–≤—Ç–æ–ø–æ–¥–±–æ—Ä–æ–º –º–∞—Ç—Ä–∏—Ü
    transpose: (text, rows, cols) => {
        const matrix = Array.from({ length: rows }, () => []);
        for (let i = 0; i < text.length; i++) {
            matrix[i % rows].push(text[i]);
        }
        return matrix.flat().join('');
    },

    // 3. –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏ N-–≥—Ä–∞–º–º—ã
    frequency: (text) => {
        const freq = {};
        for (const c of text) freq[c] = (freq[c] || 0) + 1;
        return Object.entries(freq).sort((a, b) => b[1] - a[1]);
    },

    ngrams: (text, n = 2) => {
        const grams = {};
        for (let i = 0; i < text.length - n + 1; i++) {
            const gram = text.slice(i, i + n);
            grams[gram] = (grams[gram] || 0) + 1;
        }
        return Object.entries(grams).sort((a, b) => b[1] - a[1]);
    },

    // 4. XOR-–±—Ä—É—Ç—Ñ–æ—Ä—Å
    xorBrute: (cipher, sample = ' the ') => {
        const keys = [];
        for (let key = 1; key < 256; key++) {
            const decoded = cipher.split('').map(c => 
                String.fromCharCode(c.charCodeAt(0) ^ key)
            ).join('');
            if (decoded.includes(sample)) {
                keys.push({ key: key.toString(16), decoded });
            }
        }
        return keys;
    },

    // 5. –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ Base64/HEX
    decode: (text, enc) => {
        try {
            if (enc === 'base64') return atob(text);
            if (enc === 'hex') return text.match(/.{1,2}/g)?.map(v => 
                String.fromCharCode(parseInt(v, 16))).join('') || '';
        } catch(e) { return null; }
        return text;
    }
};

function startAnalysis() {
    const cipher = document.getElementById('ciphertext').value;
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = '';

    // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–æ–∫
    ['base64', 'hex'].forEach(enc => {
        const decoded = CryptoPro.decode(cipher, enc);
        if (decoded && decoded !== cipher) {
            resultsDiv.innerHTML += `
                <div class="hypothesis">
                    <strong>ENCODING (${enc})</strong><br>
                    Decoded: <pre>${decoded.slice(0, 100)}</pre>
                </div>
            `;
        }
    });

    // 2. –ú–µ—Ç–æ–¥ –ö–∞—Å–∏—Å–∫–∏
    const keyLen = CryptoPro.kasiski(cipher);
    if (keyLen) {
        resultsDiv.innerHTML += `
            <div class="hypothesis">
                <strong>VIGENERE</strong><br>
                Possible key length: ${keyLen}
            </div>
        `;
    }

    // 3. –¢—Ä–∞–Ω—Å–ø–æ–∑–∏—Ü–∏—è
    const matrices = [2, 3, 4, 5].map(rows => ({
        rows,
        cols: Math.ceil(cipher.length / rows),
        text: CryptoPro.transpose(cipher, rows, Math.ceil(cipher.length / rows))
    }));
    
    matrices.forEach(m => {
        resultsDiv.innerHTML += `
            <div class="hypothesis">
                <strong>TRANSPOSITION (${m.rows}x${m.cols})</strong><br>
                Candidate: <pre>${m.text.slice(0, 100)}</pre>
            </div>
        `;
    });

    // 4. –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑
    const freq = CryptoPro.frequency(cipher);
    new Chart(document.getElementById('chart').getContext('2d'), {
        type: 'bar',
        data: {
            labels: freq.map(d => d[0]),
            datasets: [{ label: 'Frequency', data: freq.map(d => d[1]) }]
        }
    });

    // 5. XOR-–±—Ä—É—Ç—Ñ–æ—Ä—Å
    const xorKeys = CryptoPro.xorBrute(cipher);
    if (xorKeys.length > 0) {
        resultsDiv.innerHTML += `
            <div class="hypothesis">
                <strong>XOR</strong><br>
                Possible keys: ${xorKeys.map(k => `0x${k.key}`).join(', ')}
            </div>
        `;
    }
}
</script>
</body>
</html>
