<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vigen√®re Full Key Search</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --accent: #00bcd4;
            --match-bg: #ffeb3b33;
        }
        body {
            font-family: 'Consolas', monospace;
            background: var(--bg-color);
            color: var(--text-color);
            margin: 2rem;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        .panel {
            background: #2d2d2d;
            padding: 1.5rem;
            border-radius: 8px;
        }
        textarea, input, button {
            width: 100%;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #3d3d3d;
            border: 1px solid #4d4d4d;
            color: var(--text-color);
        }
        .match {
            background: var(--match-bg);
            padding: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h2>Input</h2>
            <textarea id="ciphertext" rows="6">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR</textarea>
            <input id="knownText" type="text" value="EAST" placeholder="Known plaintext">
            <input id="alphabet" type="text" value="KRYPTOSABCDEFGHIJLMNQUVWXZ" placeholder="Alphabet">
            <input id="maxKeyLength" type="number" value="5" min="1" placeholder="Max key length">
            <button onclick="startAnalysis()">Find All Keys</button>
        </div>
        <div class="panel">
            <h2>Results</h2>
            <div id="results"></div>
        </div>
    </div>

<script>
const Vigen√®re = {
    decrypt(ciphertext, key, alphabet) {
        return [...ciphertext].map((c, i) => {
            const keyChar = key[i % key.length];
            const cIdx = alphabet.indexOf(c);
            const kIdx = alphabet.indexOf(keyChar);
            return alphabet[(cIdx - kIdx + alphabet.length) % alphabet.length];
        }).join('');
    },

    *generateAllPossibleKeys(alphabet, maxLength) {
        function* generate(length, current) {
            if (current.length === length) {
                yield current.join('');
                return;
            }
            for (const char of alphabet) {
                yield* generate(length, [...current, char]);
            }
        }
        for (let len = 1; len <= maxLength; len++) {
            yield* generate(len, []);
        }
    },

    findAllValidKeys(ciphertext, known, alphabet, maxKeyLength) {
        const validKeys = new Map();
        const knownLen = known.length;

        for (const key of this.generateAllPossibleKeys(alphabet, maxKeyLength)) {
            const decrypted = this.decrypt(ciphertext, key, alphabet);
            let pos = decrypted.indexOf(known);
            
            while (pos !== -1) {
                if (!validKeys.has(key)) {
                    validKeys.set(key, []);
                }
                validKeys.get(key).push(pos);
                pos = decrypted.indexOf(known, pos + 1);
            }
        }

        return Array.from(validKeys.entries()).map(([key, positions]) => ({
            key,
            positions,
            decrypted: this.decrypt(ciphertext, key, alphabet)
        }));
    }
};

function startAnalysis() {
    const ciphertext = document.getElementById('ciphertext').value.toUpperCase();
    const known = document.getElementById('knownText').value.toUpperCase();
    const alphabet = [...new Set(document.getElementById('alphabet').value.toUpperCase())].join('');
    const maxKeyLength = parseInt(document.getElementById('maxKeyLength').value);

    if (alphabet.length !== 26) {
        alert('Alphabet must have 26 unique characters!');
        return;
    }

    const results = Vigen√®re.findAllValidKeys(ciphertext, known, alphabet, maxKeyLength);
    displayResults(results, known);
}

function displayResults(results, known) {
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = results.map(({key, decrypted, positions}) => `
        <div style="margin-bottom: 2rem;">
            <strong>üîë ${key}</strong> (length: ${key.length})<br>
            üìç Positions: ${positions.join(', ')}<br>
            üìú ${decrypted.replace(new RegExp(known, 'g'), '<span class="match">$&</span>')}
        </div>
    `).join('');
}
</script>
</body>
</html>
