<!DOCTYPE html>
<html>
<head>
  <title>Real Cipher Breaker</title>
  <style>
    body { font-family: monospace; max-width: 800px; margin: 0 auto; padding: 20px; }
    textarea { width: 100%; height: 100px; }
    #results { margin-top: 20px; }
    .result { background: #f5f5f5; padding: 10px; margin: 5px 0; }
  </style>
</head>
<body>
  <h1>Real Cipher Breaker</h1>
  <textarea id="input" placeholder="Вставьте зашифрованный текст..."></textarea>
  <button onclick="breakCipher()">Взломать</button>
  <div id="results"></div>

<script>
// ■■■■■■■■■■■■■■■■■■ ЯДРО АНАЛИЗАТОРА ■■■■■■■■■■■■■■■■■■
class CipherBreaker {
  constructor() {
    this.englishFreq = this._createFreqMap();
  }

  // Основной метод
  analyze(text) {
    const results = [];
    
    // 1. Проверка Base64
    const base64 = this._testBase64(text);
    if (base64) results.push(base64);
    
    // 2. Анализ Цезаря
    results.push(...this._breakCaesar(text));
    
    // 3. Виженер (только для длинных текстов)
    if (text.length > 20) {
      results.push(this._breakVigenere(text));
    }
    
    // 4. XOR-анализ
    results.push(...this._breakXor(text));
    
    // Сортировка по качеству
    return results.sort((a, b) => b.confidence - a.confidence);
  }

  // ■■■■■■■■■■■■■■■■■■ МЕТОДЫ ВЗЛОМА ■■■■■■■■■■■■■■■■■■
  _breakCaesar(text) {
    const results = [];
    for (let shift = 1; shift < 26; shift++) {
      let decrypted = "";
      for (const char of text) {
        if (/[A-Z]/i.test(char)) {
          const base = char === char.toUpperCase() ? 65 : 97;
          const code = ((char.charCodeAt(0) - base - shift + 26) % 26) + base;
          decrypted += String.fromCharCode(code);
        } else {
          decrypted += char;
        }
      }
      const confidence = this._rateText(decrypted);
      if (confidence > 50 || shift === 13) { // Всегда показываем ROT13
        results.push({
          method: `Caesar Shift ${shift}`,
          result: decrypted,
          confidence: confidence
        });
      }
    }
    return results;
  }

  _breakVigenere(text) {
    const keyLength = this._findKeyLength(text);
    let key = '';
    
    for (let i = 0; i < keyLength; i++) {
      let segment = "";
      for (let j = i; j < text.length; j += keyLength) {
        const char = text[j].toUpperCase();
        if (/[A-Z]/.test(char)) segment += char;
      }
      
      // Частотный анализ для сегмента
      const bestShift = this._findBestShift(segment);
      key += String.fromCharCode(65 + bestShift);
    }
    
    return {
      method: "Vigenère (Key: " + key + ")",
      result: this._vigenereDecrypt(text, key),
      confidence: this._rateText(this._vigenereDecrypt(text, key))
    };
  }

  _breakXor(text) {
    const results = [];
    for (let key = 32; key < 127; key++) {
      let decrypted = "";
      for (let i = 0; i < text.length; i++) {
        decrypted += String.fromCharCode(text.charCodeAt(i) ^ key);
      }
      const confidence = this._rateText(decrypted);
      if (confidence > 60) {
        results.push({
          method: `XOR (Key ${key})`,
          result: decrypted,
          confidence: confidence
        });
      }
    }
    return results;
  }

  // ■■■■■■■■■■■■■■■■■■ ВСПОМОГАТЕЛЬНЫЕ ■■■■■■■■■■■■■■■■■■
  _findBestShift(text) {
    const freq = this._calcFrequency(text);
    let bestShift = 0;
    let minDiff = Infinity;
    
    for (let shift = 0; shift < 26; shift++) {
      let diff = 0;
      for (let i = 0; i < 26; i++) {
        const expected = this.englishFreq[String.fromCharCode(65 + i)] || 0;
        diff += Math.abs(freq[i] - expected);
      }
      if (diff < minDiff) {
        minDiff = diff;
        bestShift = shift;
      }
    }
    return bestShift;
  }

  _rateText(text) {
    const commonWords = ["THE", "AND", "THAT", "HAVE"];
    let score = 0;
    const upper = text.toUpperCase();
    
    // Проверка общих слов
    for (const word of commonWords) {
      if (upper.includes(word)) score += word.length * 2;
    }
    
    // Частотный анализ
    const freq = this._calcFrequency(upper);
    for (let i = 0; i < 26; i++) {
      const char = String.fromCharCode(65 + i);
      score += 1 - Math.abs((this.englishFreq[char] || 0) - freq[i]) / 100;
    }
    
    return Math.min(100, Math.max(0, score));
  }
}

// ■■■■■■■■■■■■■■■■■■ ГОТОВЫЕ ФУНКЦИИ ■■■■■■■■■■■■■■■■■■
function breakCipher() {
  const input = document.getElementById('input').value;
  const breaker = new CipherBreaker();
  const results = breaker.analyze(input);
  
  const resultsDiv = document.getElementById('results');
  resultsDiv.innerHTML = '';
  
  results.slice(0, 5).forEach(result => {
    const div = document.createElement('div');
    div.className = 'result';
    div.innerHTML = `
      <strong>${result.method}</strong> (${Math.round(result.confidence)}%)<br>
      ${result.result}
    `;
    resultsDiv.appendChild(div);
  });
}
</script>
</body>
</html>
