<!DOCTYPE html>
<html>
<head>
    <title>CryptoGod Mode</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { --matrix: 16px; }
        body { font-family: monospace; background: #111; color: #0f0; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        canvas, pre { background: #000; padding: 10px; }
        .alert { color: #ff0; border: 1px solid #ff0; padding: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê CryptoGod Mode 2.0</h1>
        <textarea id="cipher" placeholder="Ciphertext..." rows="5"></textarea>
        <button onclick="fullAnalysis()">FULL ATTACK</button>
        <div class="grid">
            <div id="hypotheses"></div>
            <canvas id="chart"></canvas>
        </div>
        <pre id="debug"></pre>
    </div>

<script>
const CipherNinja = {
    // 1. –ú–µ—Ç–æ–¥ –ö–∞—Å–∏—Å–∫–∏ –¥–ª—è –í–∏–∂–µ–Ω–µ—Ä–∞
    kasiskiTest: (cipher, maxKeyLen = 20) => {
        const repeats = {};
        // –ü–æ–∏—Å–∫ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Ç—Ä–∏–≥—Ä–∞–º–º
        for (let i = 0; i < cipher.length - 2; i++) {
            const trigram = cipher.slice(i, i+3);
            if (!repeats[trigram]) repeats[trigram] = [];
            repeats[trigram].push(i);
        }
        
        // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π
        const distances = [];
        for (const trigram in repeats) {
            const positions = repeats[trigram];
            if (positions.length > 1) {
                for (let i = 1; i < positions.length; i++) {
                    distances.push(positions[i] - positions[i-1]);
                }
            }
        }
        
        // –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –ù–û–î
        const factors = {};
        distances.forEach(d => {
            for (let i = 2; i <= maxKeyLen; i++) {
                if (d % i === 0) factors[i] = (factors[i] || 0) + 1;
            }
        });
        
        return Object.entries(factors).sort((a,b) => b[1] - a[1])[0]?.[0] || null;
    },

    // 2. –¢—Ä–∞–Ω—Å–ø–æ–∑–∏—Ü–∏—è —Å –∞–≤—Ç–æ–ø–æ–¥–±–æ—Ä–æ–º –º–∞—Ç—Ä–∏—Ü
    findTransposition: (cipher, sample) => {
        const len = cipher.length;
        const candidates = [];
        
        // –ü–µ—Ä–µ–±–æ—Ä –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤ –º–∞—Ç—Ä–∏—Ü—ã
        for (let cols = 2; cols <= len/2; cols++) {
            const rows = Math.ceil(len / cols);
            const matrix = [];
            
            // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º
            for (let i = 0; i < rows; i++) {
                matrix[i] = [];
                for (let j = 0; j < cols; j++) {
                    const pos = i + j * rows;
                    matrix[i][j] = pos < len ? cipher[pos] : '';
                }
            }
            
            // –ß—Ç–µ–Ω–∏–µ –ø–æ —Å—Ç—Ä–æ–∫–∞–º
            const candidate = matrix.flat().join('');
            if (sample && candidate.includes(sample)) {
                return { cols, rows, text: candidate };
            }
            candidates.push({ cols, rows, text: candidate });
        }
        return candidates;
    },

    // 3. –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º –∞–ª—Ñ–∞–≤–∏—Ç–æ–º
    frequencyAttack: (cipher, langProfile = 'en') => {
        const freq = {};
        for (const c of cipher) freq[c] = (freq[c] || 0) + 1;
        const sorted = Object.entries(freq).sort((a,b) => b[1] - a[1]);
        
        // –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å —ç—Ç–∞–ª–æ–Ω–Ω—ã–º–∏ —á–∞—Å—Ç–æ—Ç–∞–º–∏
        const langFrequencies = {
            en: 'ETAOINSHRDLCUMWFGYPBVKJXQZ',
            ru: '–û–ï–ê–ò–ù–¢–°–†–í–õ–ö–ú–î–ü–£–Ø–´–¨–ì–ó–ë–ß–ô–•–ñ–®–Æ–¶–©–≠–§–™–Å'
        };
        
        const mapping = {};
        sorted.forEach(([char,], i) => {
            mapping[char] = langFrequencies[langProfile][i] || '?';
        });
        
        return {
            frequencies: sorted,
            decrypted: cipher.split('').map(c => mapping[c]).join('')
        };
    },

    // 4. –ü–æ–ª–Ω—ã–π –ø–∞–π–ø–ª–∞–π–Ω –∞–Ω–∞–ª–∏–∑–∞
    fullPipeline: (cipher, sample) => {
        const report = { steps: [] };
        
        // –®–∞–≥ 1: –ö–æ–¥–∏—Ä–æ–≤–∫–∏
        ['base64', 'hex'].forEach(enc => {
            try {
                const decoded = atob(cipher);
                if (/^[a-zA-Z]+$/.test(decoded)) {
                    report.steps.push({ type: 'encoding', name: enc, result: decoded });
                    cipher = decoded;
                }
            } catch(e) {}
        });
        
        // –®–∞–≥ 2: –ú–µ—Ç–æ–¥ –ö–∞—Å–∏—Å–∫–∏
        const keyLen = CipherNinja.kasiskiTest(cipher);
        if (keyLen) report.steps.push({ type: 'vigenere', keyLength: keyLen });
        
        // –®–∞–≥ 3: –¢—Ä–∞–Ω—Å–ø–æ–∑–∏—Ü–∏—è
        const transpositions = CipherNinja.findTransposition(cipher, sample);
        if (transpositions.text) {
            report.steps.push({ 
                type: 'transposition', 
                matrix: `${transpositions.rows}x${transpositions.cols}`,
                result: transpositions.text 
            });
        }
        
        // –®–∞–≥ 4: –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑
        const freqResult = CipherNinja.frequencyAttack(cipher);
        report.steps.push({
            type: 'frequency',
            topChars: freqResult.frequencies.slice(0,5),
            decrypted: freqResult.decrypted
        });
        
        return report;
    }
};

// –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
function drawChart(data) {
    const ctx = document.getElementById('chart').getContext('2d');
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: data.map(d => d[0]),
            datasets: [{ label: 'Frequency', data: data.map(d => d[1]) }]
        }
    });
}

async function fullAnalysis() {
    const cipher = document.getElementById('cipher').value;
    const report = CipherNinja.fullPipeline(cipher);
    
    // –†–µ–Ω–¥–µ—Ä –æ—Ç—á–µ—Ç–∞
    let html = '';
    report.steps.forEach(step => {
        html += `<div class="alert">`;
        html += `<strong>${step.type.toUpperCase()}</strong><br>`;
        
        switch(step.type) {
            case 'encoding':
                html += `Decoded ${step.name}: <pre>${step.result.slice(0, 100)}</pre>`;
                break;
            case 'vigenere':
                html += `Possible key length: ${step.keyLength}`;
                break;
            case 'transposition':
                html += `Matrix: ${step.matrix}<br>Decrypted: <pre>${step.result.slice(0,100)}</pre>`;
                break;
            case 'frequency':
                html += `Top chars: ${step.topChars.map(c => `${c[0]}(${c[1]})`).join(' ')}<br>`;
                html += `Mapped text: <pre>${step.decrypted.slice(0,100)}</pre>`;
                break;
        }
        html += `</div>`;
    });
    
    document.getElementById('hypotheses').innerHTML = html;
    drawChart(CipherNinja.frequencyAttack(cipher).frequencies);
}
</script>
</body>
</html>
