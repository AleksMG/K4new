<!DOCTYPE html>
<html>
<head>
    <title>Playfair Brute Force</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 15px;
            margin-right: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:disabled {
            background: #cccccc;
        }
        #ciphertext {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
        }
        #output {
            background: #f5f5f5;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: monospace;
        }
        .status {
            margin: 10px 0;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Playfair Brute Force</h1>
    <input type="text" id="ciphertext" value="DMQPQSPSX" placeholder="Enter ciphertext (A-Z only)">
    <div id="controls">
        <button id="start">Start</button>
        <button id="stop" disabled>Stop</button>
    </div>
    <div class="status">
        Checked: <span id="counter">0</span> | 
        Speed: <span id="speed">0</span>/sec |
        Found: <span id="found">0</span>
    </div>
    <pre id="output">Ready. Dictionary will load automatically.</pre>

    <script>
    // Полная реализация брутфорсера
    let dictionary = [];
    let isRunning = false;
    let workers = [];
    let checked = 0;
    let found = 0;
    let startTime = 0;
    let speedInterval;

    // Загрузка словаря
    async function loadDictionary() {
        try {
            const response = await fetch('words.txt');
            const text = await response.text();
            dictionary = text.split('\n')
                .map(word => word.trim().toUpperCase())
                .filter(word => word.length >= 4 && word.length <= 12 && !/(.).*\1/.test(word));
            document.getElementById('output').textContent = `Loaded ${dictionary.length} words`;
        } catch (e) {
            document.getElementById('output').textContent = `Error loading dictionary: ${e}`;
        }
    }

    // Матрица Плейфера
    function buildMatrix(key) {
        const matrix = [];
        const used = new Set();
        const alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ";
        
        // Добавляем буквы ключа
        for (const char of key) {
            const c = char === 'J' ? 'I' : char;
            if (!used.has(c)) {
                if (matrix.length === 0 || matrix[matrix.length-1].length === 5) {
                    matrix.push([]);
                }
                matrix[matrix.length-1].push(c);
                used.add(c);
            }
        }

        // Добавляем остальные буквы
        for (const char of alphabet) {
            if (!used.has(char)) {
                if (matrix.length === 0 || matrix[matrix.length-1].length === 5) {
                    matrix.push([]);
                }
                matrix[matrix.length-1].push(char);
            }
        }

        return matrix;
    }

    // Дешифровка биграммы
    function decryptBigram(a, b, matrix) {
        let aPos, bPos;
        
        // Находим позиции букв
        for (let i = 0; i < 5; i++) {
            for (let j = 0; j < 5; j++) {
                if (matrix[i][j] === a) aPos = {i, j};
                if (matrix[i][j] === b) bPos = {i, j};
            }
        }

        // Правила дешифровки
        if (aPos.i === bPos.i) { // Одна строка
            return [
                matrix[aPos.i][(aPos.j - 1 + 5) % 5],
                matrix[bPos.i][(bPos.j - 1 + 5) % 5]
            ];
        } else if (aPos.j === bPos.j) { // Один столбец
            return [
                matrix[(aPos.i - 1 + 5) % 5][aPos.j],
                matrix[(bPos.i - 1 + 5) % 5][bPos.j]
            ];
        } else { // Прямоугольник
            return [
                matrix[aPos.i][bPos.j],
                matrix[bPos.i][aPos.j]
            ];
        }
    }

    // Дешифровка всего текста
    function decryptPlayfair(ciphertext, key) {
        const matrix = buildMatrix(key);
        let plaintext = '';
        
        for (let i = 0; i < ciphertext.length; i += 2) {
            const [p1, p2] = decryptBigram(ciphertext[i], ciphertext[i+1], matrix);
            plaintext += p1 + p2;
        }
        
        return plaintext;
    }

    // Проверка на осмысленный текст
    function isMeaningful(text) {
        const common = ['THE', 'AND', 'ING', 'HER', 'HAT', 'FOR', 'ARE'];
        return common.some(word => text.includes(word));
    }

    // Запуск брутфорса
    async function startBruteForce() {
        if (isRunning) return;
        if (dictionary.length === 0) {
            await loadDictionary();
            if (dictionary.length === 0) return;
        }

        const ciphertext = document.getElementById('ciphertext').value
            .toUpperCase()
            .replace(/[^A-Z]/g, '');
        
        if (ciphertext.length % 2 !== 0) {
            document.getElementById('output').textContent = "Ciphertext must have even length";
            return;
        }

        isRunning = true;
        checked = 0;
        found = 0;
        startTime = Date.now();
        document.getElementById('start').disabled = true;
        document.getElementById('stop').disabled = false;
        document.getElementById('output').textContent = "Starting brute force...\n";

        speedInterval = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            document.getElementById('counter').textContent = checked;
            document.getElementById('speed').textContent = Math.round(checked / elapsed);
            document.getElementById('found').textContent = found;
        }, 200);

        // Используем Web Workers для многопоточности
        const workerCode = `
            ${buildMatrix.toString()}
            ${decryptBigram.toString()}
            ${decryptPlayfair.toString()}
            ${isMeaningful.toString()}
            
            onmessage = function(e) {
                const { ciphertext, words } = e.data;
                const results = [];
                
                for (const key of words) {
                    const plaintext = decryptPlayfair(ciphertext, key);
                    if (isMeaningful(plaintext)) {
                        results.push({ key, plaintext });
                    }
                }
                
                postMessage(results);
            };
        `;

        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);

        // Разделяем словарь на части
        const workerCount = navigator.hardwareConcurrency || 4;
        const chunkSize = Math.ceil(dictionary.length / workerCount);

        for (let i = 0; i < workerCount; i++) {
            const start = i * chunkSize;
            const end = start + chunkSize;
            const worker = new Worker(workerUrl);
            
            worker.postMessage({
                ciphertext: ciphertext,
                words: dictionary.slice(start, end)
            });
            
            worker.onmessage = function(e) {
                checked += e.data.length;
                found += e.data.length;
                
                for (const result of e.data) {
                    document.getElementById('output').textContent += 
                        `Found: ${result.key} => ${result.plaintext}\n`;
                }
            };
            
            workers.push(worker);
        }
    }

    // Остановка брутфорса
    function stopBruteForce() {
        if (!isRunning) return;
        
        isRunning = false;
        clearInterval(speedInterval);
        workers.forEach(worker => worker.terminate());
        workers = [];
        document.getElementById('start').disabled = false;
        document.getElementById('stop').disabled = true;
        
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
        document.getElementById('output').textContent += 
            `\nStopped. Checked ${checked} words in ${elapsed} seconds.`;
    }

    // Инициализация
    document.getElementById('start').addEventListener('click', startBruteForce);
    document.getElementById('stop').addEventListener('click', stopBruteForce);
    loadDictionary();
    </script>
</body>
</html>
