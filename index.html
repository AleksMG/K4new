<!DOCTYPE html>
<html>
<head>
  <title>Универсальный взломщик шифров</title>
  <style>
    body { font-family: monospace; max-width: 800px; margin: 0 auto; padding: 20px; }
    textarea { width: 100%; height: 150px; font-size: 16px; }
    button { padding: 10px 15px; background: #2c3e50; color: white; border: none; cursor: pointer; margin: 10px 0; }
    .result { background: #f8f9fa; padding: 15px; margin: 10px 0; border-left: 4px solid #3498db; }
    .warning { color: #e74c3c; }
    .success { color: #27ae60; }
  </style>
</head>
<body>
  <h1>Универсальный анализатор шифров</h1>
  <textarea id="input" placeholder="Вставьте любой зашифрованный текст (буквы, цифры, символы)..."></textarea>
  <button onclick="analyzeCipher()">Анализировать и взломать</button>
  <div id="results"></div>

<script>
// ■■■■■■■■■■■■■■■■■■ ЯДРО СИСТЕМЫ ■■■■■■■■■■■■■■■■■■
const CipherBreaker = {
  // Частотные словари
  freq: {
    en: this._createEnglishFreq(),
    ru: this._createRussianFreq()
  },

  // Основной метод анализа
  analyze(text) {
    const results = [];
    
    // Автодетекция типа шифра
    const cipherType = this._detectCipherType(text);
    
    // Применяем соответствующий метод
    switch(cipherType) {
      case 'caesar':
        results.push(...this._breakCaesar(text));
        break;
      case 'vigenere':
        results.push(this._breakVigenere(text));
        break;
      case 'base64':
        results.push(this._decodeBase64(text));
        break;
      case 'xor':
        results.push(...this._breakXor(text));
        break;
      default:
        results.push(this._tryAdvancedMethods(text));
    }
    
    return {
      cipherType: cipherType,
      results: results.sort((a,b) => b.confidence - a.confidence)
    };
  },

  // ■■■■■■■■■■■■■■■■■■ МЕТОДЫ АНАЛИЗА ■■■■■■■■■■■■■■■■■■
  _detectCipherType(text) {
    // Анализ характеристик текста
    const features = {
      entropy: this._calcEntropy(text),
      charDistribution: this._calcCharDistribution(text),
      base64Like: /^[A-Za-z0-9+/=]+$/.test(text)
    };

    // Логика определения
    if (features.base64Like && text.length % 4 === 0) return 'base64';
    if (features.entropy > 4.5) return 'xor';
    if (this._isCaesarLike(text)) return 'caesar';
    if (text.length > 20 && this._isVigenereLike(text)) return 'vigenere';
    
    return 'unknown';
  },

  // ■■■■■■■■■■■■■■■■■■ МЕТОДЫ ВЗЛОМА ■■■■■■■■■■■■■■■■■■
  _breakCaesar(text) {
    const results = [];
    for (let shift = 1; shift < 26; shift++) {
      let decrypted = "";
      for (const char of text) {
        if (/[A-Z]/i.test(char)) {
          const base = char === char.toUpperCase() ? 65 : 97;
          const code = ((char.charCodeAt(0) - base - shift + 26) % 26 + base;
          decrypted += String.fromCharCode(code);
        } else {
          decrypted += char;
        }
      }
      const confidence = this._calcConfidence(decrypted);
      if (confidence > 50 || shift === 13) {
        results.push({
          method: `Шифр Цезаря (сдвиг ${shift})`,
          result: decrypted,
          confidence: confidence
        });
      }
    }
    return results;
  },

  _breakVigenere(text, maxKeyLength = 8) {
    const keyLength = this._findKeyLength(text);
    let bestKey = '';
    let bestScore = -Infinity;
    
    // Генетический алгоритм поиска ключа
    for (let attempt = 0; attempt < 100; attempt++) {
      const key = this._generateRandomKey(keyLength);
      const decrypted = this._vigenereDecrypt(text, key);
      const score = this._calcConfidence(decrypted);
      
      if (score > bestScore) {
        bestScore = score;
        bestKey = key;
      }
    }
    
    return {
      method: `Шифр Виженера (ключ: ${bestKey})`,
      result: this._vigenereDecrypt(text, bestKey),
      confidence: bestScore
    };
  },

  _breakXor(text) {
    const results = [];
    // Перебор ключей от 1 до 255
    for (let key = 1; key <= 255; key++) {
      let decrypted = "";
      for (let i = 0; i < text.length; i++) {
        decrypted += String.fromCharCode(text.charCodeAt(i) ^ key);
      }
      const confidence = this._calcConfidence(decrypted);
      if (confidence > 60) {
        results.push({
          method: `XOR (ключ ${key})`,
          result: decrypted,
          confidence: confidence
        });
      }
    }
    return results.slice(0, 5); // Топ-5 результатов
  },

  // ■■■■■■■■■■■■■■■■■■ ВСПОМОГАТЕЛЬНЫЕ ■■■■■■■■■■■■■■■■■■
  _calcConfidence(text) {
    // Анализ текста на естественность
    let score = 0;
    const clean = text.replace(/[^A-Za-z]/g, '').toUpperCase();
    
    if (clean.length < 3) return 0;
    
    // Проверка частот букв
    for (const char of clean) {
      score += this.freq.en[char] || -3;
    }
    
    // Проверка общих слов
    const commonWords = ["THE", "AND", "THAT", "HAVE", "WITH"];
    for (const word of commonWords) {
      if (clean.includes(word)) score += word.length * 5;
    }
    
    return Math.min(100, Math.max(0, score / clean.length * 100));
  },

  _vigenereDecrypt(text, key) {
    let result = "";
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (/[A-Z]/i.test(char)) {
        const base = char === char.toUpperCase() ? 65 : 97;
        const keyChar = key[i % key.length].toUpperCase();
        const shift = keyChar.charCodeAt(0) - 65;
        const code = ((char.charCodeAt(0) - base - shift + 26) % 26 + base;
        result += String.fromCharCode(code);
      } else {
        result += char;
      }
    }
    return result;
  }
};

// ■■■■■■■■■■■■■■■■■■ ИНТЕРФЕЙС ■■■■■■■■■■■■■■■■■■
function analyzeCipher() {
  const input = document.getElementById('input').value.trim();
  if (!input) {
    alert("Введите текст для анализа!");
    return;
  }

  const resultsDiv = document.getElementById('results');
  resultsDiv.innerHTML = '<div class="result">Анализируем текст...</div>';

  setTimeout(() => {
    try {
      const analysis = CipherBreaker.analyze(input);
      let output = `
        <div class="result">
          <strong>Определенный тип шифра:</strong> ${analysis.cipherType.toUpperCase()}
        </div>
      `;
      
      if (analysis.results.length > 0) {
        analysis.results.forEach(res => {
          output += `
            <div class="result">
              <strong>${res.method}</strong> (точность: ${Math.round(res.confidence)}%)<br>
              ${res.result.length > 100 ? res.result.substring(0, 100) + '...' : res.result}
            </div>
          `;
        });
      } else {
        output += '<div class="result warning">Не удалось определить шифр или взломать текст</div>';
      }
      
      // Добавляем советы
      output += `
        <div class="result">
          <strong>Рекомендации:</strong><br>
          ${getAdvice(analysis)}
        </div>
      `;
      
      resultsDiv.innerHTML = output;
    } catch (e) {
      resultsDiv.innerHTML = `<div class="result warning">Ошибка: ${e.message}</div>`;
    }
  }, 300);
}

function getAdvice(analysis) {
  if (analysis.results.some(r => r.confidence > 70)) {
    return "Высокая точность расшифровки - вероятно, это правильный результат";
  }
  
  switch(analysis.cipherType) {
    case 'caesar':
      return "Попробуйте разные сдвиги вручную (ROT13 - сдвиг 13)";
    case 'vigenere':
      return "Для Виженера нужен длинный текст (>50 символов) для точного анализа";
    case 'xor':
      return "XOR-шифры сложно взломать без знания длины ключа";
    default:
      return "Это может быть: 1) Составной шифр 2) Кодировка 3) Неизвестный алгоритм";
  }
}
</script>
</body>
</html>
