<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>True Vigen√®re Reverse Engineering</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --accent: #00bcd4;
            --match-bg: #ffeb3b33;
        }
        body {
            font-family: 'Consolas', monospace;
            background: var(--bg-color);
            color: var(--text-color);
            margin: 2rem;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        .panel {
            background: #2d2d2d;
            padding: 1.5rem;
            border-radius: 8px;
        }
        textarea, input, button {
            width: 100%;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #3d3d3d;
            border: 1px solid #4d4d4d;
            color: var(--text-color);
        }
        .match {
            background: var(--match-bg);
            padding: 2px;
        }
        .warning {
            color: #ffa726;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h2>Input</h2>
            <textarea id="ciphertext" rows="6">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR</textarea>
            <input id="knownText" type="text" value="EAST" placeholder="Known plaintext">
            <input id="alphabet" type="text" value="KRYPTOSABCDEFGHIJLMNQUVWXZ" placeholder="Alphabet">
            <input id="maxKeyLen" type="number" value="10" min="1" placeholder="Max key length">
            <button onclick="start()">Analyze</button>
        </div>
        <div class="panel">
            <h2>Results</h2>
            <div id="results"></div>
        </div>
    </div>

<script>
class Vigen√®reSolver {
    static decrypt(ciphertext, key, alphabet) {
        return Array.from(ciphertext).map((c, i) => {
            const keyChar = key[i % key.length];
            const cIdx = alphabet.indexOf(c);
            const kIdx = alphabet.indexOf(keyChar);
            return alphabet[(cIdx - kIdx + alphabet.length) % alphabet.length];
        }).join('');
    }

    static findKeys(ciphertext, known, alphabet, maxKeyLen) {
        const candidates = new Map();
        const n = ciphertext.length - known.length;
        
        // –≠—Ç–∞–ø 1: –ù–∞–π—Ç–∏ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –∫–ª—é—á–∞
        for (let pos = 0; pos <= n; pos++) {
            const keyFragment = Array.from(known).map((pChar, i) => {
                const c = ciphertext[pos + i];
                const pIdx = alphabet.indexOf(pChar);
                const cIdx = alphabet.indexOf(c);
                return (pIdx !== -1 && cIdx !== -1)
                    ? alphabet[(cIdx - pIdx + alphabet.length) % alphabet.length]
                    : null;
            });
            
            if (keyFragment.every(c => c !== null)) {
                const keyStr = keyFragment.join('');
                if (!candidates.has(keyStr)) {
                    candidates.set(keyStr, { positions: [pos], count: 1 });
                } else {
                    candidates.get(keyStr).positions.push(pos);
                    candidates.get(keyStr).count++;
                }
            }
        }

        // –≠—Ç–∞–ø 2: –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –∫–ª—é—á–µ–π
        const validKeys = [];
        for (const [key, data] of candidates) {
            if (key.length > maxKeyLen) continue;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–≥–æ—Å—è –ø–∞—Ç—Ç–µ—Ä–Ω–∞
            let isRepeating = false;
            for (let len = 1; len <= key.length/2; len++) {
                const pattern = key.slice(0, len);
                if (key === pattern.repeat(Math.ceil(key.length/len)).slice(0, key.length)) {
                    isRepeating = true;
                    break;
                }
            }
            
            if (!isRepeating) {
                validKeys.push({
                    key,
                    positions: data.positions,
                    score: data.count * key.length
                });
            }
        }

        // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∫–∞—á–µ—Å—Ç–≤—É –∫–ª—é—á–∞
        return validKeys.sort((a, b) => b.score - a.score);
    }
}

function start() {
    const ciphertext = document.getElementById('ciphertext').value.toUpperCase();
    const known = document.getElementById('knownText').value.toUpperCase();
    const alphabet = [...new Set(document.getElementById('alphabet').value.toUpperCase())].join('');
    const maxKeyLen = parseInt(document.getElementById('maxKeyLen').value) || 10;

    if (alphabet.length !== 26) {
        alert("Alphabet must contain exactly 26 unique characters!");
        return;
    }

    const results = Vigen√®reSolver.findKeys(ciphertext, known, alphabet, maxKeyLen);
    displayResults(results, ciphertext, alphabet, known);
}

function displayResults(results, ciphertext, alphabet, known) {
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = results.length === 0 
        ? '<div class="warning">No valid keys found!</div>'
        : results.map(({key, positions}) => {
            const decrypted = Vigen√®reSolver.decrypt(ciphertext, key, alphabet);
            return `
                <div style="margin-bottom: 2rem;">
                    <strong>üîë ${key}</strong> (length: ${key.length})<br>
                    üìç Matches at: ${positions.join(', ')}<br>
                    üìú Decrypted: ${highlight(decrypted, known)}
                </div>
            `;
        }).join('');
}

function highlight(text, phrase) {
    const regex = new RegExp(phrase, 'gi');
    return text.replace(regex, '<span class="match">$&</span>');
}
</script>
</body>
</html>
